---
id: 2019-05-09-KMP.md
author: Anon
layout: post
title: 算法（一）：KMP
date: 2019/5/9
categories: 算法
tags: 数据结构
description: 一个算法白痴对于KMP算法的学习记录。
editor: Typora
static_data_dir: https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png
---


* content
{:toc}
KMP算法应该算是我学习程序开发以来第一个真正独立学习理解的算法，看了许多网络上的视频和文字教程依旧很难彻底掌握（尤其是next数组的计算过程），所以我将我对于该算法的主观认识记录于此。

___

## BF

Brute-Force(BF) 算法又称naive算法，是对字符串子串搜索最简单明了的算法。其主旨就是： 

1. 不处理模式串
2. 模式串从目标串**第一个元素**起逐一匹配
3. 发现无法匹配，模式串匹配右移一位，从下一位目标串元素重新初始逐一元素匹配

<center><div style="text-align: center;"><img style="height:;width:100%;" alt="" title="" src="http://ss.showyoumycode.com/StaticData/Blog/KMP/bf_quickest.gif"></div></center>

虽然简单易懂，但是同时也导致了复杂度较高，最慢的情形其复杂度可以到达O（模式串长 * 目标串长）。

<center><div style="text-align: center;"><img style="height:;width:100%;" alt="" title="" src="http://ss.showyoumycode.com/StaticData/Blog/KMP/bf_lowest.gif"></div></center>

## KMP

但是如果仔细观察，可以发现**模式串**本身是可以自带一些**可被预先计算出**的**可用于加速匹配的信息**的。

当模式串的第K位失配时，前K-1位必然是匹配的，如果直接整体后移一位重新从头开始匹配那之前的那些**已经匹配的信息**就被浪费了。于是我们可以寻找**最大的必定不需要再匹配的串**，那这个串是什么呢？

很显然，这个串就是[1,K-1]位串中**最大且相同**的**头尾**串（S）。当失配发生，可以直接**保持目标串中的失配元素不变**，移动模式串，K-1-S串长个单位重新匹配，这就是KMP算法。

为什么要移动K-1-S串长个单位？失配元素前方一共有K-1个元素，最大相同头尾串长为S。意味着

<center><div style="text-align: center;"><img style="height:;width:100%;" alt="" title="" src="http://ss.showyoumycode.com/StaticData/Blog/KMP/KMP.gif"></div></center>